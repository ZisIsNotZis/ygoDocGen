# YGOPro Documentation Generator
Generate YGOPro Lua Documentation by automatically inspecting C++ source file

# Brief Description
This Python script generates `ygopro` Lua Documentation by automatically inspecting C++ source file. It's not really robust and it strongly relies on fixed coding convension (like spacing). This file can be used by `DataEditorX`, which havn't updated its `_functions.txt` for billions of year.

Currently some coding convension fix (basically adding white space) need to be done to the upstream. Trying to create a Pull Requet.

# Usage
Simply put the script under `ygopro-core` master branch folder and run it. It outputs to STDOUT. Techincally it requires `python 3.x` and no other package (The regex module `re` is shipped as part of python). It probably can be easily modify it to `python 2.x` script by fixign the `print` statement

# Example Output (It's kind of problematic, I know)
    ●integer Effect.GetCode(effect peffect)
    ●integer Card.GetOriginalCode(card pcard)
    ●integer Card.GetOriginalCodeRule(card pcard)
    ●integer Card.GetFusionCode(card pcard)
    ●integer Card.GetLinkCode(card pcard)
    ●boolean Card.IsFusionCode(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tcode')]
    ●boolean Card.IsLinkCode(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tcode')]
    ●boolean Card.IsSetCard(card pcard, uint32 set_code)
    ●boolean Card.IsOriginalSetCard(card pcard, uint32 set_code)
    ●boolean Card.IsPreviousSetCard(card pcard, uint32 set_code)
    ●boolean Card.IsFusionSetCard(card pcard, uint32 set_code)
    ●boolean Card.IsLinkSetCard(card pcard, uint32 set_code)
    ●integer Effect.GetType(effect peffect)
    ●integer Card.GetOriginalType(card pcard)
    ●integer Card.GetFusionType(card pcard)
    ●integer Card.GetSynchroType(card pcard)
    ●integer Card.GetXyzType(card pcard)
    ●integer Card.GetLinkType(card pcard)
    ●integer Card.GetLevel(card pcard)
    ●integer Card.GetRank(card pcard)
    ●integer Card.GetLink(card pcard)
    ●integer Card.GetSynchroLevel(card pcard, card scard)
    ●integer Card.GetRitualLevel(card pcard, card scard)
    ●integer Card.GetOriginalLevel(card pcard)
    ●integer Card.GetOriginalRank(card pcard)
    ●boolean Card.IsXyzLevel(card pcard, card xyzcard, uint32 lv)
    ●integer Card.GetLeftScale(card pcard)
    ●integer Card.GetOriginalLeftScale(card pcard)
    ●integer Card.GetRightScale(card pcard)
    ●integer Card.GetOriginalRightScale(card pcard)
    ●boolean Card.IsLinkMarker(card pcard, uint32 dir)
    ●group Duel.GetLinkedGroup(uint32 rplayer, uint32 s, uint32 o)
    ●integer Duel.GetLinkedGroupCount(uint32 rplayer, uint32 s, uint32 o)
    ●integer Duel.GetLinkedZone(uint32 playerid)
    ●group Card.GetMutualLinkedGroup(card pcard)
    ●integer Card.GetMutualLinkedGroupCount(card pcard)
    ●integer Card.GetMutualLinkedZone(card pcard, integer cp)
    ●boolean Card.IsLinkState(card pcard)
    ●boolean Card.IsExtraLinkState(card pcard)
    ●group Card.GetColumnGroup(card pcard)
    ●integer Card.GetColumnGroupCount(card pcard)
    ●integer Card.GetColumnZone(card pcard, int32 loc, integer cp)
    ●boolean Card.IsAllColumn(card pcard)
    ●integer Card.GetAttribute(card pcard)
    ●integer Card.GetOriginalAttribute(card pcard)
    ●integer Card.GetFusionAttribute(card pcard, integer playerid)
    ●integer Card.GetLinkAttribute(card pcard, integer playerid)
    ●integer Card.GetRace(card pcard)
    ●integer Card.GetOriginalRace(card pcard)
    ●integer Card.GetLinkRace(card pcard, integer playerid)
    ●integer Card.GetAttack(card pcard)
    ●integer Card.GetBaseAttack(card pcard)
    ●integer Card.GetTextAttack(card pcard)
    ●integer Card.GetBaseDefense(card pcard)
    ●integer Card.GetTextDefense(card pcard)
    ●integer Card.GetPreviousCodeOnField(card pcard)
    ●integer Card.GetPreviousTypeOnField(card pcard)
    ●integer Card.GetPreviousLevelOnField(card pcard)
    ●integer Card.GetPreviousRankOnField(card pcard)
    ●integer Card.GetPreviousAttributeOnField(card pcard)
    ●integer Card.GetPreviousRaceOnField(card pcard)
    ●integer Card.GetPreviousAttackOnField(card pcard)
    ●integer Card.GetPreviousDefenseOnField(card pcard)
    ●card Effect.GetOwner(effect peffect)
    ●integer Card.GetControler(card pcard)
    ●integer Card.GetPreviousControler(card pcard)
    ●integer Card.GetReason(card pcard)
    ●card Card.GetReasonCard(card pcard)
    ●integer Card.GetReasonPlayer(card pcard)
    ●effect Card.GetReasonEffect(card pcard)
    ●integer Card.GetPosition(card pcard)
    ●integer Card.GetPreviousPosition(card pcard)
    ●integer Card.GetBattlePosition(card pcard)
    ●integer Card.GetLocation(card pcard)
    ●integer Card.GetPreviousLocation(card pcard)
    ●integer Card.GetSequence(card pcard)
    ●integer Card.GetPreviousSequence(card pcard)
    ●integer Card.GetSummonType(card pcard)
    ●integer Card.GetSummonLocation(card pcard)
    ●integer Card.GetSummonPlayer(card pcard)
    ●integer Card.GetDestination(card pcard)
    ●integer Card.GetLeaveFieldDest(card pcard)
    ●integer Card.GetTurnID(card pcard)
    ●integer Effect.GetFieldID(effect peffect)
    ●integer Card.GetRealFieldID(card pcard)
    ●boolean Card.IsCode(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tcode')]
    ●boolean Card.IsType(card pcard, uint32 ttype)
    ●boolean Card.IsFusionType(card pcard, uint32 ttype)
    ●boolean Card.IsSynchroType(card pcard, uint32 ttype)
    ●boolean Card.IsXyzType(card pcard, uint32 ttype)
    ●boolean Card.IsLinkType(card pcard, uint32 ttype)
    ●boolean Card.IsLevel(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tlevel')]
    ●boolean Card.IsRank(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'trank')]
    ●boolean Card.IsLink(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tlink')]
    ●boolean Card.IsAttack(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tatk')]
    ●boolean Card.IsDefense(card pcard, uint32 count)
     variable position arguments: [('', None), ('uint32', 'tdef')]
    ●boolean Card.IsRace(card pcard, uint32 trace)
    ●boolean Card.IsLinkRace(card pcard, uint32 trace, integer playerid)
    ●boolean Card.IsAttribute(card pcard, uint32 tattrib)
    ●boolean Card.IsFusionAttribute(card pcard, uint32 tattrib, integer playerid)
    ●boolean Card.IsLinkAttribute(card pcard, uint32 tattrib, integer playerid)
    ●boolean Card.IsReason(card pcard, uint32 treason)
    ●boolean Card.IsSummonType(card pcard, uint32 ttype)
    ●boolean Card.IsStatus(card pcard, uint32 tstatus)
    ●boolean Card.IsNotTuner(card pcard, card scard)
    ●void Card.SetStatus(card pcard, uint32 tstatus, int32 enable)
    ●boolean Card.IsDualState(card pcard)
    ●void Card.EnableDualState(card pcard)
    ●integer Card.GetTurnCounter(card pcard)
    ●void Card.SetMaterial(card pcard, group pgroup)
    ●group Card.GetMaterial(card pcard)
    ●integer Card.GetMaterialCount(card pcard)
    ●group Card.GetEquipGroup(card pcard)
    ●integer Card.GetEquipCount(card pcard)
    ●card Card.GetEquipTarget(card pcard)
    ●card Card.GetPreviousEquipTarget(card pcard)
    ●boolean Card.CheckEquipTarget(card pcard, card target)
    ●integer Card.GetUnionCount(card pcard)
    ●group Duel.GetOverlayGroup(uint32 rplayer, uint32 s, uint32 o)
    ●integer Duel.GetOverlayCount(uint32 rplayer, uint32 s, uint32 o)
    ●card Card.GetOverlayTarget(card pcard)
    ●boolean Duel.CheckRemoveOverlayCard(int32 playerid, uint32 s, uint32 o, int32 count, int32 reason)
    ●??? Duel.RemoveOverlayCard(int32 playerid, uint32 s, uint32 o, int32 min, int32 max, int32 reason)
    ●group Card.GetAttackedGroup(card pcard)
    ●integer Card.GetAttackedGroupCount(card pcard)
    ●integer Card.GetAttackedCount(card pcard)
    ●group Card.GetBattledGroup(card pcard)
    ●integer Card.GetBattledGroupCount(card pcard)
    ●integer Card.GetAttackAnnouncedCount(card pcard)
    ●boolean Card.IsDirectAttacked(card pcard)
    ●void Card.SetCardTarget(card pcard, card ocard)
    ●group Card.GetCardTarget(card pcard)
    ●nil|card Card.GetFirstCardTarget(card pcard)
    ●integer Card.GetCardTargetCount(card pcard)
    ●boolean Card.IsHasCardTarget(card pcard, card rcard)
    ●void Card.CancelCardTarget(card pcard, card rcard)
    ●group Card.GetOwnerTarget(card pcard)
    ●integer Card.GetOwnerTargetCount(card pcard)
    ●effect Card.GetActivateEffect(card pcard)
    ●group|effect|integer Card.CheckActivateEffect(card pcard, int32 neglect_con, int32 neglect_cost, int32 copy_info)
    ●function|nil|effect|integer Card.GetTunerLimit(card pcard)
    ●function|nil|effect|integer Card.GetHandSynchro(card pcard)
    ●void Duel.RegisterEffect(effect peffect, uint32 playerid)
    ●nil|effect Card.IsHasEffect(card pcard, uint32 code)
    ●void Card.ResetEffect(card pcard, uint32 code, uint32 type)
    ●integer Card.GetEffectCount(card pcard, uint32 code)
    ●effect Duel.RegisterFlagEffect(int32 playerid, int32 code, int32 reset, int32 flag, int32 count, integer lab)
    ●integer Duel.GetFlagEffect(int32 playerid, int32 code)
    ●void Duel.ResetFlagEffect(int32 playerid, uint32 code)
    ●boolean Duel.SetFlagEffectLabel(int32 playerid, uint32 code, int32 lab)
    ●nil|integer Duel.GetFlagEffectLabel(int32 playerid, uint32 code)
    ●void Card.CreateRelation(card pcard, card rcard, uint32 reset)
    ●void Card.ReleaseRelation(card pcard, card rcard)
    ●void Card.CreateEffectRelation(card pcard, effect peffect)
    ●void Card.ReleaseEffectRelation(card pcard, effect peffect)
    ●void Card.ClearEffectRelation(card pcard)
    ●boolean Card.IsRelateToEffect(card pcard, effect peffect)
    ●boolean Card.IsRelateToChain(card pcard, uint32 chain_count)
    ●boolean Card.IsRelateToCard(card pcard, card rcard)
    ●boolean Card.IsRelateToBattle(card pcard)
    ●integer Card.CopyEffect(card pcard, uint32 code, uint32 reset, uint32 count)
    ●integer Card.ReplaceEffect(card pcard, uint32 code, uint32 reset, uint32 count)
    ●void Card.EnableUnsummonable(card pcard)
    ●void Card.EnableReviveLimit(card pcard)
    ●void Card.CompleteProcedure(card pcard)
    ●boolean Card.IsDisabled(card pcard)
    ●boolean Card.IsDestructable(card pcard, effect peffect)
    ●boolean Card.IsSummonableCard(card pcard)
    ●boolean Card.IsFusionSummonableCard(card pcard, integer summon_type)
    ●boolean Card.IsSpecialSummonable(card pcard, integer sumtype)
    ●boolean Card.IsSynchroSummonable(card pcard, card tuner, group mg)
    ●boolean Card.IsXyzSummonable(card pcard, group materials, integer minc, integer maxc)
    ●boolean Card.IsSummonable(card pcard, uint32 ign, effect peffect, integer minc, integer zone)
    ●boolean Card.IsMSetable(card pcard, uint32 ign, effect peffect, integer minc, integer zone)
    ●boolean Card.IsSSetable(card pcard, boolean ign)
    ●boolean Card.IsCanBeSpecialSummoned(card pcard, effect peffect, uint32 sumtype, uint32 sumplayer, uint32 nocheck, uint32 nolimit, integer sumpos, integer toplayer, integer zone)
    ●boolean Card.IsAbleToHand(card pcard)
    ●boolean Card.IsAbleToDeck(card pcard)
    ●boolean Card.IsAbleToExtra(card pcard)
    ●boolean Card.IsAbleToGrave(card pcard)
    ●boolean Card.IsAbleToRemove(card pcard, integer p)
    ●boolean Card.IsAbleToHandAsCost(card pcard)
    ●boolean Card.IsAbleToDeckAsCost(card pcard)
    ●boolean Card.IsAbleToExtraAsCost(card pcard)
    ●boolean Card.IsAbleToDeckOrExtraAsCost(card pcard)
    ●boolean Card.IsAbleToGraveAsCost(card pcard)
    ●boolean Card.IsAbleToRemoveAsCost(card pcard)
    ●boolean Card.IsReleasable(card pcard)
    ●boolean Card.IsReleasableByEffect(card pcard)
    ●boolean Card.IsDiscardable(card pcard, integer reason)
    ●boolean Card.IsAttackable(card pcard)
    ●boolean Card.IsChainAttackable(card pcard, integer ac, boolean monsteronly)
    ●boolean Card.IsFaceup(card pcard)
    ●boolean Card.IsAttackPos(card pcard)
    ●boolean Card.IsFacedown(card pcard)
    ●boolean Card.IsDefensePos(card pcard)
    ●boolean Card.IsPosition(card pcard, uint32 pos)
    ●boolean Card.IsPreviousPosition(card pcard, uint32 pos)
    ●boolean Card.IsControler(card pcard, uint32 con)
    ●boolean Card.IsOnField(card pcard)
    ●boolean Card.IsLocation(card pcard, uint32 loc)
    ●boolean Card.IsPreviousLocation(card pcard, uint32 loc)
    ●boolean Card.IsLevelBelow(card pcard, uint32 lvl)
    ●boolean Card.IsLevelAbove(card pcard, uint32 lvl)
    ●boolean Card.IsRankBelow(card pcard, uint32 rnk)
    ●boolean Card.IsRankAbove(card pcard, uint32 rnk)
    ●boolean Card.IsLinkBelow(card pcard, uint32 lnk)
    ●boolean Card.IsLinkAbove(card pcard, uint32 lnk)
    ●boolean Card.IsAttackBelow(card pcard, int32 atk)
    ●boolean Card.IsAttackAbove(card pcard, int32 atk)
    ●boolean Card.IsDefenseBelow(card pcard, int32 def)
    ●boolean Card.IsDefenseAbove(card pcard, int32 def)
    ●boolean Card.IsPublic(card pcard)
    ●boolean Card.IsForbidden(card pcard)
    ●boolean Card.IsAbleToChangeControler(card pcard)
    ●boolean Card.IsControlerCanBeChanged(card pcard, boolean ign, integer zone)
    ●boolean Card.AddCounter(card pcard, uint32 countertype, uint32 count, boolean singly)
    ●??? Duel.RemoveCounter(uint32 rplayer, uint32 s, uint32 o, uint32 countertype, uint32 count, uint32 reason)
    ●integer Duel.GetCounter(uint32 playerid, uint32 s, uint32 o, uint32 countertype)
    ●void Card.EnableCounterPermit(card pcard, int32 countertype, integer prange)
    ●void Card.SetCounterLimit(card pcard, int32 countertype, int32 limit)
    ●boolean Card.IsCanChangePosition(card pcard)
    ●boolean Card.IsCanTurnSet(card pcard)
    ●boolean Duel.IsCanAddCounter(int32 playerid, int32 countertype, int32 count, card pcard)
    ●boolean Duel.IsCanRemoveCounter(uint32 rplayer, uint32 s, uint32 o, uint32 countertype, uint32 count, uint32 reason)
    ●boolean Card.IsCanBeFusionMaterial(card pcard, card fcard)
    ●boolean Card.IsCanBeSynchroMaterial(card pcard, card scard, card tuner)
    ●boolean Card.IsCanBeRitualMaterial(card pcard, card scard)
    ●boolean Card.IsCanBeXyzMaterial(card pcard, card scard)
    ●boolean Card.IsCanBeLinkMaterial(card pcard, card scard)
    ●boolean Card.CheckFusionMaterial(card pcard, group pgroup, card cg, integer chkf)
    ●boolean Card.CheckFusionSubstitute(card pcard, card fcard)
    ●boolean Card.IsImmuneToEffect(card pcard, effect peffect)
    ●boolean Card.IsCanBeEffectTarget(card pcard, effect peffect)
    ●boolean Card.IsCanBeBattleTarget(card pcard, card bcard)
    ●void Card.AddMonsterAttribute(card pcard, int32 type, int32 attribute, int32 race, int32 level, int32 atk, int32 def)
    ●void Card.AddMonsterAttributeComplete()
    ●void Card.CancelToGrave(card pcard, boolean cancel)
    ●integer Card.GetTributeRequirement(card pcard)
    ●nil|card Card.GetBattleTarget(card pcard)
    ●boolean|group Card.GetAttackableTarget(card pcard)
    ●void Card.SetHint(card pcard, uint32 type, uint32 value)
    ●void Card.ReverseInDeck(card pcard)
    ●void Card.SetUniqueOnField(card pcard, integer pcard->unique_pos[0], integer pcard->unique_pos[1], on|integer pcard->unique_code, integer location)
    ●boolean Card.CheckUniqueOnField(card pcard, uint32 check_player, integer check_location, card icard)
    ●void Card.ResetNegateEffect(uint32|card pcard|count)
     variable position arguments: [('pcard->rese', 'pcard')]
    ●void Card.AssumeProperty(card pcard, integer pcard->assume_type, integer pcard->assume_value)
    ●void Card.SetSPSummonOnce(card pcard, integer pcard->spsummon_code)
    ●effect Effect.CreateEffect(card pcard)
    ●effect Effect.GlobalEffect()
    ●group Group.Clone(group pgroup)
    ●void Effect.Reset(effect peffect)
    ●void Effect.SetDescription(effect peffect, uint32 v)
    ●void Effect.SetCode(effect peffect, uint32 v)
    ●void Effect.SetRange(effect peffect, uint32 v)
    ●void Effect.SetTargetRange(effect peffect, uint32 s, uint32 o)
    ●void Effect.SetAbsoluteRange(effect peffect, uint32 playerid, uint32 s, uint32 o)
    ●void Effect.SetCountLimit(effect peffect, uint32 v, integer code)
    ●void Effect.SetReset(effect peffect, uint32 v, uint32 c)
    ●void Effect.SetType(effect peffect, uint32 v)
    ●void Effect.SetProperty(effect peffect, uint32 v1, uint32 v2)
    ●void Effect.SetLabel(effect peffect, uint32 v)
    ●void Effect.SetLabelObject(effect peffect, card|effect|group p)
    ●void Effect.SetCategory(effect peffect, uint32 v)
    ●void Effect.SetHintTiming(effect peffect, uint32 vs, integer vo)
    ●void Effect.SetCondition(effect peffect, function ???)
    ●void Effect.SetTarget(effect peffect, function ???)
    ●void Effect.SetCost(effect peffect, function ???)
    ●void Effect.SetValue(effect peffect, boolean|number|on|n peffect->value)
    ●void Effect.SetOperation(effect peffect, function ???)
    ●void Effect.SetOwnerPlayer(effect peffect, uint32 p)
    ●integer Effect.GetDescription(effect peffect)
    ●integer Effect.GetProperty(effect peffect)
    ●integer Effect.GetLabel(effect peffect)
    ●nil Effect.GetLabelObject(effect peffect)
     variable position arguments: [('ta', None)]
    ●integer Effect.GetCategory(effect peffect)
    ●card Effect.GetHandler(effect peffect)
    ●function Effect.GetCondition(effect peffect)
    ●function Effect.GetTarget(effect peffect)
    ●function Effect.GetCost(effect peffect)
    ●function|integer Effect.GetValue(effect peffect)
    ●function Effect.GetOperation(effect peffect)
    ●integer Effect.GetActiveType(effect peffect)
    ●boolean Effect.IsActiveType(effect peffect, uint32 type)
    ●integer Effect.GetOwnerPlayer(effect peffect)
    ●integer Effect.GetHandlerPlayer(effect peffect)
    ●boolean Effect.IsHasProperty(effect peffect, uint32 tflag1, uint32 tflag2)
    ●boolean Effect.IsHasCategory(effect peffect, uint32 tcate)
    ●boolean Effect.IsHasType(effect peffect, uint32 ttype)
    ●boolean Effect.IsActivatable(effect peffect, uint32 playerid, boolean neglect_loc, boolean neglect_target)
    ●boolean Effect.IsActivated(effect peffect)
    ●integer Effect.GetActivateLocation(effect peffect)
    ●integer Effect.GetActivateSequence(effect peffect)
    ●boolean Effect.CheckCountLimit(effect peffect, uint32 p)
    ●void Effect.UseCountLimit(effect peffect, uint32 p, integer count, boolean oath_only)
    ●group Group.CreateGroup()
    ●void Group.KeepAlive(group pgroup)
    ●void Group.DeleteGroup(group pgroup)
    ●uint32|group Group.FromCards()
     variable position arguments: [('', None), ('card', None), ('card', 'pcard')]
    ●void Group.Clear(group pgroup)
    ●card Debug.AddCard(int32 code, int32 owner, int32 playerid, int32 location, int32 sequence, int32 position, int32 proc)
    ●void Group.RemoveCard(group pgroup, card pcard)
    ●nil|card Group.GetNext(group pgroup)
    ●nil|card Group.GetFirst(group pgroup)
    ●integer Group.GetCount(group pgroup)
    ●void Group.ForEach(group pgroup, uint32|function extraargs)
    ●group Group.Filter(group pgroup, function ???, uint32|group|card pexception|pexgroup|extraargs)
    ●integer Group.FilterCount(group pgroup, function ???, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Group.FilterSelect(group pgroup, uint32 playerid, function ???, uint32 min, uint32 max, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Group.Select(group pgroup, uint32 playerid, uint32 min, uint32 max, group|card pexception|pexgroup)
    ●??? Group.SelectUnselect(group pgroup1, group pgroup2, uint32 playerid, boolean finishable, boolean cancelable, integer min, integer max)
    ●??? Group.RandomSelect(group pgroup, int32 playerid, int32 count)
    ●boolean Group.IsExists(group pgroup, function ???, uint32 count, uint32|group|card pexception|pexgroup|extraargs)
    ●boolean Group.CheckWithSumEqual(group pgroup, function ???, int32 acc, int32 min, uint32|int32 max|extraargs)
    ●group Group.SelectWithSumEqual(group pgroup, int32 playerid, function ???, int32 acc, int32 min, uint32|int32 max|extraargs)
    ●boolean Group.CheckWithSumGreater(group pgroup, function ???, uint32|int32 acc|extraargs)
    ●group Group.SelectWithSumGreater(group pgroup, int32 playerid, function ???, uint32|int32 acc|extraargs)
    ●group|integer Group.GetMinGroup(group pgroup, uint32|function extraargs)
    ●group|integer Group.GetMaxGroup(group pgroup, uint32|function extraargs)
    ●integer Group.GetSum(group pgroup, uint32|function extraargs)
    ●integer Group.GetClassCount(group pgroup, uint32|function extraargs)
    ●??? Duel.Remove(group|card pcard|pgroup, uint32 pos, uint32 reason)
    ●void Group.Merge(group pgroup, group mgroup)
    ●void Group.Sub(group pgroup, group sgroup)
    ●boolean Group.Equal(group pgroup, group sgroup)
    ●boolean Group.IsContains(group pgroup, card pcard)
    ●card Group.SearchCard(group pgroup, uint32|function extraargs)
    ●integer Group.GetBinClassCount(group pgroup, uint32|function extraargs)
    ●void Duel.EnableGlobalFlag(int32 flag)
    ●integer Duel.GetLP(int32 p)
    ●void Duel.SetLP(int32 p, int32 lp)
    ●integer Duel.GetTurnPlayer()
    ●integer Duel.GetTurnCount(int32 playerid)
    ●integer Duel.GetDrawCount(int32 playerid)
    ●??? Duel.Destroy(group|card pcard|pgroup, uint32 reason, integer dest)
    ●??? Duel.SendtoGrave(group|card pcard|pgroup, uint32 reason)
    ●??? Duel.SendtoHand(group|card pcard|pgroup, uint32 playerid, uint32 reason)
    ●??? Duel.SendtoDeck(group|card pcard|pgroup, uint32 playerid, uint32 sequence, uint32 reason)
    ●??? Duel.SendtoExtraP(group|card pcard|pgroup, uint32 playerid, uint32 reason)
    ●group Duel.GetOperatedGroup()
    ●??? Duel.Summon(uint32 playerid, card pcard, uint32 ignore_count, effect peffect, integer min_tribute, integer zone)
    ●??? Duel.SpecialSummonRule(uint32 playerid, card pcard, integer sumtype)
    ●??? Duel.SynchroSummon(uint32 playerid, card pcard, card tuner, group mg)
    ●??? Duel.XyzSummon(uint32 playerid, card pcard, group materials, integer minc, integer maxc)
    ●??? Duel.MSet(uint32 playerid, card pcard, uint32 ignore_count, effect peffect, integer min_tribute, integer zone)
    ●??? Duel.SSet(uint32 playerid, group|card pcard|pgroup, integer toplayer, boolean confirm)
    ●boolean|card Duel.CreateToken(int32 playerid, int32 code)
    ●??? Duel.SpecialSummon(group|card pcard|pgroup, uint32 sumtype, uint32 sumplayer, uint32 playerid, uint32 nocheck, uint32 nolimit, uint32 positions, integer zone)
    ●??? Duel.SpecialSummonStep(card pcard, uint32 sumtype, uint32 sumplayer, uint32 playerid, uint32 nocheck, uint32 nolimit, uint32 positions, integer zone)
    ●??? Duel.SpecialSummonComplete()
    ●??? Duel.ChangePosition(group|card pcard|pgroup, uint32 au, 2) ad, 3) du, 4) dd, if(top > 5 & dd, if(top > 6 &|uint32 top|dd)
    ●??? Duel.Release(group|card pcard|pgroup, uint32 reason)
    ●??? Duel.MoveToField(card pcard, uint32 move_player, uint32 playerid, uint32 destination, uint32 positions, uint32 enable, integer zone)
    ●??? Duel.ReturnToField(card pcard, integer pos, integer zone)
    ●void Duel.MoveSequence(card pcard, int32 seq)
    ●void Duel.SwapSequence(card pcard1, card pcard2)
    ●void Duel.Activate(effect peffect)
    ●void Duel.SetChainLimit(function ???)
    ●void Duel.SetChainLimitTillChainEnd(function ???)
    ●effect Duel.GetChainMaterial(int32 playerid)
    ●??? Duel.ConfirmDecktop(int32 playerid, uint32 count)
    ●??? Duel.ConfirmExtratop(int32 playerid, uint32 count)
    ●??? Duel.ConfirmCards(int32 playerid, group|card pcard|pgroup)
    ●??? Duel.SortDecktop(uint32 sort_player, uint32 target_player, uint32 count)
    ●boolean|group|effect|integer Duel.CheckEvent(int32 ev, int32 get_info)
    ●??? Duel.RaiseEvent(group|card pcard|pgroup, uint32 code, effect peffect, uint32 r, uint32 rp, uint32 ep, uint32 ev)
    ●??? Duel.RaiseSingleEvent(card pcard, uint32 code, effect peffect, uint32 r, uint32 rp, uint32 ep, uint32 ev)
    ●boolean Duel.CheckTiming(int32 tm)
    ●integer Duel.GetEnvironment()
    ●boolean Duel.IsEnvironment(uint32 code, integer playerid, integer loc)
    ●void Duel.Win(uint32 playerid, uint32 reason)
    ●??? Duel.Draw(uint32 playerid, uint32 count, uint32 reason)
    ●??? Duel.Damage(uint32 playerid, int32 amount, uint32 reason, boolean is_step)
    ●??? Duel.Recover(uint32 playerid, int32 amount, uint32 reason, boolean is_step)
    ●??? Duel.RDComplete()
    ●??? Duel.Equip(uint32 playerid, card equip_card, card target, boolean up, boolean step)
    ●??? Duel.EquipComplete()
    ●??? Duel.GetControl(group|card pcard|pgroup, uint32 playerid, integer reset_phase, integer reset_count, integer zone)
    ●??? Duel.SwapControl(group|card pgroup1|pcard1, group|card pgroup2|pcard2, integer reset_phase, integer reset_count)
    ●boolean Duel.CheckLPCost(uint32 playerid, uint32 cost)
    ●??? Duel.PayLPCost(uint32 playerid, uint32 cost)
    ●??? Duel.DiscardDeck(uint32 playerid, uint32 count, uint32 reason)
    ●integer Duel.DiscardHand(uint32 playerid, function ???, uint32 min, uint32 max, uint32 reason, uint32|group|card pexception|pexgroup|extraargs)
    ●void Duel.DisableShuffleCheck(boolean disable)
    ●void Duel.ShuffleDeck(uint32 playerid)
    ●void Duel.ShuffleExtra(uint32 playerid)
    ●void Duel.ShuffleHand(uint32 playerid)
    ●void Duel.ShuffleSetCard(group pgroup)
    ●void Duel.ChangeAttacker(card attacker, boolean ignore_count)
    ●boolean Duel.ChangeAttackTarget(card target)
    ●??? Duel.CalculateDamage(card attacker, card attack_target, boolean new_attack)
    ●integer Duel.GetBattleDamage(int32 playerid)
    ●void Duel.ChangeBattleDamage(int32 playerid, int32 dam, boolean check)
    ●void Duel.ChangeTargetCard(uint32 count, group pgroup)
    ●void Duel.ChangeTargetPlayer(uint32 count, uint32 playerid)
    ●void Duel.ChangeTargetParam(uint32 count, uint32 param)
    ●??? Duel.BreakEffect()
    ●void Duel.ChangeChainOperation(uint32 count, function ???)
    ●boolean Duel.NegateActivation(uint32 c)
    ●boolean Duel.NegateEffect(uint32 c)
    ●void Duel.NegateRelatedChain(card pcard, uint32 reset_flag)
    ●void Duel.NegateSummon(group|card pcard|pgroup)
    ●void Duel.IncreaseSummonedCount(card pcard)
    ●boolean Duel.CheckSummonedCount(card pcard)
    ●integer Duel.GetLocationCount(uint32 playerid, uint32 location, integer uplayer, integer reason, integer zone)
    ●integer Duel.GetMZoneCount(uint32 playerid, group|card mcard|mgroup, integer uplayer, integer reason, integer zone)
    ●integer Duel.GetLocationCountFromEx(uint32 playerid, integer uplayer, group|card mcard|mgroup, card scard, integer zone)
    ●integer Duel.GetUsableMZoneCount(uint32 playerid, integer uplayer)
    ●card Duel.GetFieldCard(uint32 playerid, uint32 location, uint32 sequence)
    ●boolean Duel.CheckLocation(uint32 playerid, uint32 location, uint32 sequence)
    ●integer Duel.GetCurrentChain()
    ●group|nil|effect|integer Duel.GetChainInfo(uint32 c, uint32 args|flag)
    ●group|effect|integer Duel.GetChainEvent(uint32 count)
    ●card Duel.GetFirstTarget()
    ●integer Duel.GetCurrentPhase()
    ●void Duel.SkipPhase(uint32 playerid, uint32 phase, uint32 reset, uint32 count, uint32 value)
    ●boolean Duel.IsDamageCalculated()
    ●card Duel.GetAttacker()
    ●card Duel.GetAttackTarget()
    ●??? Duel.NegateAttack()
    ●void Duel.ChainAttack(card pduel->game_field->core.chain_attack_target)
    ●??? Duel.Readjust()
    ●void Duel.AdjustInstantly(card pcard)
    ●group Duel.GetFieldGroup(uint32 playerid, uint32 location1, uint32 location2)
    ●integer Duel.GetFieldGroupCount(uint32 playerid, uint32 location1, uint32 location2)
    ●group Duel.GetDecktopGroup(uint32 playerid, uint32 count)
    ●group Duel.GetExtraTopGroup(uint32 playerid, uint32 count)
    ●group Duel.GetMatchingGroup(function ???, uint32 self, uint32 location1, uint32 location2, uint32|group|card pexception|pexgroup|extraargs)
    ●integer Duel.GetMatchingGroupCount(function ???, uint32 self, uint32 location1, uint32 location2, uint32|group|card pexception|pexgroup|extraargs)
    ●nil|card Duel.GetFirstMatchingCard(function ???, uint32 self, uint32 location1, uint32 location2, uint32|group|card pexception|pexgroup|extraargs)
    ●boolean Duel.IsExistingMatchingCard(function ???, uint32 self, uint32 location1, uint32 location2, uint32 fcount, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Duel.SelectMatchingCard(uint32 playerid, function ???, uint32 self, uint32 location1, uint32 location2, uint32 min, uint32 max, uint32|group|card pexception|pexgroup|extraargs)
    ●group Duel.GetReleaseGroup(uint32 playerid, boolean hand)
    ●integer Duel.GetReleaseGroupCount(uint32 playerid, boolean hand)
    ●boolean Duel.CheckReleaseGroup(int32 playerid, function ???, uint32 fcount, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Duel.SelectReleaseGroup(int32 playerid, function ???, uint32 min, uint32 max, uint32|group|card pexception|pexgroup|extraargs)
    ●boolean Duel.CheckReleaseGroupEx(int32 playerid, function ???, uint32 fcount, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Duel.SelectReleaseGroupEx(int32 playerid, function ???, uint32 min, uint32 max, uint32|group|card pexception|pexgroup|extraargs)
    ●group Duel.GetTributeGroup(card target)
    ●integer Duel.GetTributeCount(card target, group mg, boolean ex)
    ●boolean Duel.CheckTribute(card target, uint32 min, integer max, group mg, integer toplayer, integer zone)
    ●??? Duel.SelectTribute(uint32 playerid, card target, uint32 min, uint32 max, group mg, integer toplayer)
    ●integer Duel.GetTargetCount(function ???, uint32 self, uint32 location1, uint32 location2, uint32|group|card pexception|pexgroup|extraargs)
    ●boolean Duel.IsExistingTarget(function ???, uint32 self, uint32 location1, uint32 location2, uint32 count, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Duel.SelectTarget(uint32 playerid, function ???, uint32 self, uint32 location1, uint32 location2, uint32 min, uint32 max, uint32|group|card pexception|pexgroup|extraargs)
    ●??? Duel.SelectFusionMaterial(int32 playerid, card pcard, group pgroup, card cg, integer chkf)
    ●void Duel.SetFusionMaterial(group pgroup)
    ●void Duel.SetSynchroMaterial(group pgroup)
    ●value Duel.SelectSynchroMaterial(int32 playerid, card pcard, function ???, function ???, int32 min, int32 max, card smat, group mg)
    ●boolean|value Duel.CheckSynchroMaterial(card pcard, function ???, function ???, int32 min, int32 max, card smat, group mg)
    ●value Duel.SelectTunerMaterial(int32 playerid, card pcard, card tuner, function ???, function ???, int32 min, int32 max, group mg)
    ●boolean|value Duel.CheckTunerMaterial(card pcard, card tuner, function ???, function ???, int32 min, int32 max, group mg)
    ●group Duel.GetRitualMaterial(int32 playerid)
    ●??? Duel.ReleaseRitualMaterial(group pgroup)
    ●group Duel.GetFusionMaterial(int32 playerid)
    ●void Duel.SetSelectedCard(group|card pcard|pgroup)
    ●group Duel.GrabSelectedCard()
    ●void Duel.SetTargetCard(group|card pcard|pgroup)
    ●void Duel.ClearTargetCard()
    ●void Duel.SetTargetPlayer(uint32 playerid)
    ●void Duel.SetTargetParam(uint32 param)
    ●void Duel.SetOperationInfo(uint32 ct, uint32 cate, group|card pcard|pgroup, uint32 count, uint32 playerid, uint32 param)
    ●boolean|group|nil|integer Duel.GetOperationInfo(uint32 ct, uint32 cate)
    ●integer Duel.GetOperationCount(uint32 ct)
    ●boolean Duel.CheckXyzMaterial(card scard, function ???, uint32 lv, uint32 minc, uint32 maxc, group mg)
    ●??? Duel.SelectXyzMaterial(uint32 playerid, card scard, function ???, uint32 lv, uint32 minc, uint32 maxc, group mg)
    ●??? Duel.Overlay(card target, group|card pcard|pgroup)
    ●void Duel.Hint(int32 htype, int32 playerid, int32 desc)
    ●void Duel.HintSelection(group pgroup)
    ●??? Duel.SelectEffectYesNo(int32 playerid, card pcard, integer desc)
    ●??? Duel.SelectYesNo(int32 playerid, int32 desc)
    ●??? Duel.SelectOption(uint32|int32 playerid|count)
     variable position arguments: [('pduel->game_field->core.select_options.push_bac', 'playerid')]
    ●void Duel.SelectSequence()
    ●??? Duel.SelectPosition(int32 playerid, card pcard, uint32 positions)
    ●??? Duel.SelectDisableField(int32 playerid, uint32 count, uint32 location1, uint32 location2, uint32 filter)
    ●??? Duel.AnnounceRace(int32 playerid, int32 count, int32 available)
    ●??? Duel.AnnounceAttribute(int32 playerid, int32 count, int32 available)
    ●??? Duel.AnnounceLevel(int32 playerid, integer min, uint32|integer j|max)
     variable position arguments: [('if (!lua_isnil(L, j) && i =', 'max')]
    ●??? Duel.AnnounceCard(int32 playerid, integer ttype)
    ●??? Duel.AnnounceCardFilter(int32 playerid, uint32 i)
     variable position arguments: [('pduel->game_field->core.select_options.push_bac', 'playerid')]
    ●??? Duel.AnnounceType(int32 playerid)
    ●??? Duel.AnnounceNumber(int32 playerid, uint32 i)
     variable position arguments: [('pduel->game_field->core.select_options.push_bac', 'playerid')]
    ●??? Duel.AnnounceCoin(int32 playerid)
    ●??? Duel.TossCoin(int32 playerid, int32 count)
    ●??? Duel.TossDice(int32 playerid, int32 count1, integer count2)
    ●??? Duel.RockPaperScissors(boolean repeat)
    ●integer Duel.GetCoinResult()
    ●integer Duel.GetDiceResult()
    ●void Duel.SetCoinResult()
     variable position arguments: [('integer', 'res')]
    ●void Duel.SetDiceResult()
     variable position arguments: [('integer', 'res')]
    ●nil|effect Duel.IsPlayerAffectedByEffect(int32 playerid, int32 code)
    ●boolean Duel.IsPlayerCanDraw(int32 playerid, integer count)
    ●boolean Duel.IsPlayerCanDiscardDeck(int32 playerid, int32 count)
    ●boolean Duel.IsPlayerCanDiscardDeckAsCost(int32 playerid, int32 count)
    ●boolean Duel.IsPlayerCanSummon(int32 playerid, int32 sumtype, card pcard)
    ●boolean Duel.IsPlayerCanSpecialSummon(int32 playerid, int32 sumtype, int32 sumpos, int32 toplayer, card pcard)
    ●boolean Duel.IsPlayerCanFlipSummon(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanSpecialSummonMonster(int32|integer playerid|toplayer|sumtype|pos, int32 code, integer dat.setcode, integer dat.type, integer dat.attack, integer dat.defense, integer dat.level, integer dat.race, integer dat.attribute)
    ●boolean Duel.IsPlayerCanSpecialSummonCount(int32 playerid, int32 count)
    ●boolean Duel.IsPlayerCanRelease(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanRemove(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanSendtoHand(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanSendtoGrave(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanSendtoDeck(int32 playerid, card pcard)
    ●boolean Duel.IsPlayerCanAdditionalSummon(int32 playerid)
    ●boolean Duel.IsChainNegatable(int32 chaincount)
    ●boolean Duel.IsChainDisablable(int32 chaincount)
    ●boolean Duel.CheckChainTarget(int32 chaincount, card pcard)
    ●boolean Duel.CheckChainUniqueness()
    ●integer Duel.GetActivityCount(int32 playerid, uint32|int32 activity_type|retct)
    ●boolean Duel.CheckPhaseActivity()
    ●void Duel.AddCustomActivityCounter(int32 counter_id, int32 activity_type, function ???)
    ●integer Duel.GetCustomActivityCount(int32 counter_id, int32 playerid, int32 activity_type)
    ●integer Duel.GetBattledCount(int32 playerid)
    ●boolean Duel.IsAbleToEnterBP()
    ●boolean Duel.VenomSwampCheck(??? ???, card pcard)
    ●void Duel.SwapDeckAndGrave(int32 playerid)
    ●void Duel.MajesticCopy(card pcard, card ccard)
    ●value Debug.Message()
     variable position arguments: [('interpreter::sprintf(pduel->strbuffer, "%s"', None)]
    ●void Debug.SetPlayerInfo(uint32 playerid, uint32 lp, uint32 startcount, uint32 drawcount)
    ●void Debug.PreSummon(card pcard, uint32 summon_type, integer summon_location)
    ●boolean Debug.PreEquip(card equip_card, card target)
    ●void Debug.PreSetTarget(card t_card, card target)
    ●void Debug.PreAddCounter(card pcard, uint32 countertype, uint32 count)
    ●void Debug.ReloadFieldBegin(uint32 flag, int32 rule)
    ●void Debug.ReloadFieldEnd()
    ●void Debug.SetAIName(string|char pstr)
    ●void Debug.ShowHint(string|char pstr)
